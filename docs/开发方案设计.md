# 合约订单监控开发方案

> **对齐要求**：全文以 `docs/场景用例.md` 所列场景作为唯一业务判定基线，任何逻辑设计均不得增删该文档的场景条件；若提及场景，均沿用原文命名（例如“市价单一次性全部成交”）以消除歧义。

## 1. 范围与目标

- **交易品类**：币安 U 本位合约（USDⓈ-M Futures），监听 `ORDER_TRADE_UPDATE` 用户数据流事件。
- **监控对象**：
  - 市价单的成交事件（含一次性成交、10 秒内聚合完成、10 秒内未完成等场景）。
  - 客户端订单号以 `SL` 或 `TP` 开头的订单在创建、取消、成交、部分成交（含 10 秒聚合与取消）场景。
- **通知形式**：飞书自定义机器人卡片消息，字段与内容严格参照 `docs/场景用例.md`。创建/取消场景会在主机器人之外同步推送至备用 webhook（`https://open.feishu.cn/open-apis/bot/v2/hook/2b097171-60ad-476e-ae90-a78e301bb791`）。

## 2. 功能需求（逐条映射场景）

| 场景 | 触发条件（ORDER_TRADE_UPDATE 字段） | 推送内容 | 备注 |
| --- | --- | --- | --- |
| 市价单一次性全部成交 | `o.ot = "MARKET"` 且 `o.X = "FILLED"`，无历史累计 | 状态=市价成交，Size=`o.q`，累计成交量=`o.z`，均价=`o.ap` | 接到事件即发送，无需等待 |
| 市价单分批成交且 10 秒内全部完成 | `MARKET`，`o.X` 先为 `PARTIALLY_FILLED` 后变 `FILLED`，窗口内完成 | 同一次性成交，但累计数量与均价为窗口内合并值 | 首次 `PARTIALLY_FILLED` 启动 10 秒计时 |
| 市价单分批成交但 10 秒内无新增成交 | `MARKET`，10 秒计时内没有新成交事件 | 状态=市价成交，Size=`o.q`，累计成交量=当前 `o.z`，均价按 `o.ap` 或 `cumulativeQuote / cumulativeQty` | 发送后等待新事件再开启新窗口 |
| `SL/TP` 创建 | `o.ot != "MARKET"`，`o.c` 以 `SL`/`TP` 开头，`o.X = "NEW"` | 状态=创建，Size=`o.q`，价格=`o.p`，累计成交量不展示 | |
| `SL/TP` 取消 | 同上，`o.X = "CANCELED"` | 状态=取消，Size=`o.q`（或剩余，见实现细则），价格=`o.p` | 若在聚合窗口内取消需合并成交信息 |
| `SL/TP` 完全成交 | 同上，`o.X = "FILLED"` | 状态=成交，Size=`o.q`，累计成交量=`o.z`，均价=`o.ap` | |
| `SL/TP` 部分成交且 10 秒内完成 | `o.X = "PARTIALLY_FILLED"` 后 10 秒内变 `FILLED` | 状态=成交（或约定状态字段与场景一致），累计成交量为聚合结果 | 聚合同市价单策略 |
| `SL/TP` 部分成交但 10 秒内未补足 | `o.X = "PARTIALLY_FILLED"`，10 秒计时结束仍未 `FILLED` | 状态=成交或部分成交（实现中统一文案），累计成交量=`o.z`，价格=加权平均 | |
| `SL/TP` 部分成交后取消 | 10 秒内收到 `CANCELED` | 状态=取消，累计成交量=`o.z`，Size 保留原下单量，价格根据约定（优先挂单价） | |

> **字段速记**（`o` 为事件对象）：
> - `o.x`：执行类型（`NEW`、`TRADE`、`CANCELED` 等）
> - `o.X`：订单状态（`NEW`、`PARTIALLY_FILLED`、`FILLED`、`CANCELED` 等）
> - `o.ot`：订单类型（`MARKET`、`LIMIT` 等）
> - `o.c`：客户端订单号（clientOrderId）
> - `o.q`：原始下单数量
> - `o.z`：累计成交数量
> - `o.l`：本次成交数量
> - `o.ap`：平均成交价格
> - `o.p`：委托价格

## 3. 技术架构

### 3.1 总体结构

```
src/
  config/          # 配置加载与校验
  binance/
    listenKeyClient.ts
    streamClient.ts
  orders/
    eventMapper.ts
    stateTracker.ts
    aggregator.ts
  notifications/
    cardBuilder.ts
    notifier.ts
  app/
    service.ts
  utils/
    logger.ts
    time.ts
  tests/           # Vitest/Jest 测试文件
```

- **数据流**：listenKey → WebSocket → `eventMapper` → `stateTracker` → `aggregator` → `cardBuilder` → `notifier`。
- **语言**：TypeScript（Node.js ≥18，ESM/TS 模块）。

### 3.2 模块职责

| 模块 | 关键职责与接口 |
| --- | --- |
| `config` | 使用 `dotenv` 读取环境变量，`zod` 校验；暴露 `AppConfig` 对象，含 API Key、Secret、webhook URL、聚合窗口（默认 10 秒）、ListenKey keep-alive 周期（默认 30 分钟）、日志级别等。 |
| `binance/listenKeyClient` | 通过 `POST /fapi/v1/listenKey` 获取 listenKey；`PUT /fapi/v1/listenKey` 定期续期；`DELETE /fapi/v1/listenKey` 在关闭时清理。提供 `create()`, `keepAlive()`, `destroy()`，内部使用 `axios`/`@binance/connector`。 |
| `binance/streamClient` | 基于 `ws` 连接 `wss://fstream.binance.com/ws/<listenKey>`（或测试网）。处理自动重连、心跳检测、`listenKeyExpired` 事件。将 `ORDER_TRADE_UPDATE` 原始 JSON 推入事件总线。 |
| `orders/eventMapper` | 将原始事件映射为 `OrderEvent`（见 §4 数据模型），过滤非 `ORDER_TRADE_UPDATE`，并判断订单是否为目标（市价或 `SL/TP` 前缀）。 |
| `orders/stateTracker` | 维护每个订单的最新状态（原始数量、累计成交量、平均价、当前状态、最后事件时间）。供 `aggregator` 调用以获得最新累计数据。 |
| `orders/aggregator` | 根据 `docs/场景用例.md` 的聚合规则为每个订单维护 10 秒窗口：
  - 首次部分成交创建 `setTimeout` 计时器。
  - 新事件到达时更新累计数据并在必要时提前触发（如 `FILLED`、`CANCELED`）。
  - 超时后输出聚合结果并清理上下文。
  输出统一的 `OrderNotificationInput`。 |
| `notifications/cardBuilder` | 将 `OrderNotificationInput` 转换为飞书自适应卡片 JSON，字段与文案严格遵循 `docs/场景用例.md`。 |
| `notifications/notifier` | 使用 `axios` POST 至 webhook，内置 `p-retry`（最大重试 3 次，指数退避）。对 4xx/5xx 写日志并返回。 |
| `app/service` | 应用入口：加载配置、初始化日志、创建 listenKey、启动流、注册信号处理（SIGINT/SIGTERM）、优雅关闭。 |
| `utils/logger` | 封装 `pino`，提供结构化日志（字段包含 orderId、clientOrderId、symbol 等）。 |

## 4. 数据模型

### 4.1 TypeScript 接口

```ts
type OrderSide = "BUY" | "SELL";
type OrderStatus = "NEW" | "PARTIALLY_FILLED" | "FILLED" | "CANCELED" | "EXPIRED" | string;
type OrderType = "MARKET" | "LIMIT" | string;

interface RawOrderTradeUpdate {
  e: "ORDER_TRADE_UPDATE";
  E: number;          // 事件时间（ms）
  T: number;          // 撮合时间（ms）
  o: {
    s: string;        // 交易对
    c: string;        // 客户端订单号
    S: OrderSide;
    o: OrderType;
    x: string;        // 执行类型
    X: OrderStatus;   // 订单状态
    i: number;        // 订单 ID
    q: string;        // 原始数量
    z: string;        // 累计成交量
    l: string;        // 本次成交量
    ap: string;       // 平均成交价
    L: string;        // 最后成交价
    p: string;        // 委托价格
    T: number;        // 交易时间
    rp?: string;      // 已实现盈亏
    b?: string;       // 余额变化
    m: boolean;       // 是否为 maker
    ...
  };
}

interface OrderEvent {
  symbol: string;
  orderId: number;
  clientOrderId: string;
  side: OrderSide;
  orderType: OrderType;
  status: OrderStatus;
  eventTime: Date;
  tradeTime: Date;
  originalQuantity: string;
  cumulativeQuantity: string;
  lastQuantity: string;
  averagePrice: string;
  lastPrice: string;
  orderPrice: string;
  isMaker: boolean;
  raw: RawOrderTradeUpdate;
}

interface AggregationContext {
  symbol: string;
  orderId: number;
  clientOrderId: string;
  orderType: OrderType;
  originalQuantity: string;
  cumulativeQuantity: string;
  cumulativeQuote: string; // 通过 sum(lastPrice * lastQty) 计算
  lastAveragePrice: string;
  lastStatus: OrderStatus;
  lastEventTime: Date;
  timer?: NodeJS.Timeout;
}

interface OrderNotificationInput {
  scenario: string;  // 对应 docs/场景用例.md 中的具体场景标题
  symbol: string;
  stateLabel: string;
  size: string;
  cumulativeQuantity?: string;
  displayPrice: string;
  notifyTime: Date;
  orderType: OrderType;
  status: OrderStatus;
  isMarket: boolean;
  isStopOrTakeProfit: boolean;
  rawEvents: OrderEvent[];
}

interface FeishuCardPayload {
  msg_type: "interactive";
  card: Record<string, unknown>;
}
```

### 4.2 关键派生字段

- **Size**：取 `originalQuantity`。
- **累计成交量**：取 `cumulativeQuantity`（如为空则在卡片中省略）。
- **平均成交价**：优先使用 `averagePrice`；若字段为 `0`，以 `cumulativeQuote / cumulativeQuantity` 计算。
- **价格（挂单价）**：非市价单使用 `orderPrice`。
- **通知时间**：以事件合成完成时间 `notifyTime`（通常为聚合触发时的 `Date.now()`）。

## 5. 处理流程细化

### 5.1 启动阶段

1. `config.load()` → 检查必要配置，若缺失直接退出并提示。
2. 初始化 `logger`（输出 level、timestamp、module）。
3. `listenKeyClient.create()` → 获取 listenKey，失败重试 5 次（指数退避 1/2/4/8/16 秒）。
4. `streamClient.connect(listenKey)`：
   - 注册 `message`、`close`、`error` 监听。
   - 若连接断开，触发重连：重新申请 listenKey → 恢复流。
5. 启动 `listenKey keep-alive` 定时器（默认 25 分钟调用 `keepAlive`，留安全 buffer）。

### 5.2 事件管线

1. WebSocket 收到消息 → JSON.parse → 校验 `zod` schema：非 `ORDER_TRADE_UPDATE` 直接忽略。
2. `eventMapper`: 
   - 将 `RawOrderTradeUpdate` 转成 `OrderEvent`。
   - 判断是否为关注订单：
     - 市价单：`orderType === "MARKET"`。
     - `SL/TP`：`clientOrderId` 以 `SL` 或 `TP` 开头（大小写敏感规则与 `docs/场景用例.md` 一致）。
   - 非目标订单 → 跳过。
3. `stateTracker.upsert(event)`：
   - 更新累计成交量、加权报价（`cumulativeQuote += Number(lastPrice) * Number(lastQuantity)`）。
   - 保存最后状态、事件时间。
4. `aggregator.process(event, context)`：
   - 根据场景表执行：
     - **终态（FILLED/CANCELED）**：立即生成通知，清理计时器。
     - **部分成交**：
       - 若无计时器，新建 10 秒 `setTimeout`，记录 `scenario`。
       - 若已有计时器，刷新累计数据并决定是否提前触发（e.g. 变为 `FILLED`/`CANCELED`）。
     - **创建 NEW**：非聚合事件，直接输出通知。
   - 输出 `OrderNotificationInput` 或 `null`。
5. 对于非 null 的通知输入：
   - `cardBuilder.build(input)` → 返回 `FeishuCardPayload`。
   - `notifier.send(payload)` → 成功后记录 info 日志；失败时记录 error 并重试。

### 5.3 聚合策略与场景对应

| 场景 | 聚合策略说明 |
| --- | --- |
| 市价单一次性全部成交 | `aggregator` 在收到首个且状态为 `FILLED` 的事件时立即输出。 |
| 市价单分批成交且 10 秒内全部完成 | 首次 `PARTIALLY_FILLED` 设置定时器；若在 10 秒内收到 `FILLED`，立即触发通知并取消计时器。 |
| 市价单分批成交但 10 秒内无新增成交 | 计时器到期时触发通知，使用当前累计数量、均价；若后续继续成交，则重启计时器并在新窗口内再次通知。 |
| `SL/TP` 创建 | 无聚合，`eventMapper` 直接触发。 |
| `SL/TP` 取消 | 若处于聚合窗口，先更新累计成交量后立即输出；否则直接输出。 |
| `SL/TP` 完全成交 | 同市价单终态处理。 |
| `SL/TP` 部分成交且 10 秒内完成 | 与市价单同逻辑。 |
| `SL/TP` 部分成交但 10 秒内未补足 | 计时器到期输出，状态在实现中统一为“成交”或“部分成交”（需在卡片模板中反映）。 |
| `SL/TP` 部分成交后取消 | 在窗口内收到 `CANCELED` 时立即输出，状态=取消，累计成交量带上部分成交数。 |

> **注意**：所有聚合输出都必须在 `OrderNotificationInput.scenario` 中填入与 `docs/场景用例.md` 完全一致的标题，便于后续测试覆写。

## 6. 飞书卡片模板

- **Header**：`{symbol}-{source}`（例如 `BTCUSDT-止盈`）。模板颜色仍依据状态（创建=蓝色、成交=绿色、部分成交=橙色、取消=红色）。
- **主体元素**（顺序固定，以保障视觉一致）：
  1. 状态行：`状态: {stateLabel}`。
  2. 字段组 1：`方向: {买入/卖出}`。
  3. 字段组 2：`Size: {size}` 与（如存在）`累计成交量: {cumulativeQuantity}`。
  4. 字段组 3：根据场景选择显示 `平均成交价格` 或 `价格`：成交/部分成交 → `平均成交价格: {displayPrice}`；创建/取消 → `价格: {displayPrice}`（触发型订单会自动回退至触发价）。
  5. 通知时间行：`通知时间: {notifyTimeFormatted}`（使用 `dayjs().format('YYYY-MM-DD HH:mm:ss')` + 时区）。
- **payload 校验**：构建完成后通过 `zod` schema 断言字段完整性。

## 7. 配置项清单

| 环境变量 | 说明 | 默认值 |
| --- | --- | --- |
| `BINANCE_API_KEY` | 合约账户 API Key | 必填 |
| `BINANCE_API_SECRET` | 合约账户 API Secret | 必填 |
| `BINANCE_BASE_URL` | REST 基地址 (`https://fapi.binance.com` 或测试网) | `https://fapi.binance.com` |
| `BINANCE_WS_BASE_URL` | WebSocket 基地址 (`wss://fstream.binance.com/ws`) | `wss://fstream.binance.com/ws` |
| `FEISHU_WEBHOOK_URL` | 主要飞书机器人 webhook | 必填 |
| `FEISHU_SECONDARY_WEBHOOK_URL` | 创建/取消通知专用飞书 webhook | `https://open.feishu.cn/open-apis/bot/v2/hook/2b097171-60ad-476e-ae90-a78e301bb791` |
| `AGGREGATION_WINDOW_MS` | 聚合窗口毫秒数 | `10000` |
| `LISTEN_KEY_KEEP_ALIVE_MS` | listenKey 保活周期 | `1500000` (25 分钟) |
| `LOG_LEVEL` | 日志级别 (`info` / `debug` / `warn` / `error`) | `info` |
| `MAX_RETRY` | 通知发送最大重试次数 | `3` |
| `POSITION_VALIDATION_INTERVAL_MS` | 持仓校验轮询间隔（毫秒） | `30000` |

- **配置示例（.env）**：
  ```dotenv
  BINANCE_API_KEY=your_api_key
  BINANCE_API_SECRET=your_secret
  BINANCE_BASE_URL=https://fapi.binance.com
  BINANCE_WS_BASE_URL=wss://fstream.binance.com/ws
  FEISHU_WEBHOOK_URL=https://open.feishu.cn/open-apis/bot/v2/hook/primary
  FEISHU_SECONDARY_WEBHOOK_URL=https://open.feishu.cn/open-apis/bot/v2/hook/2b097171-60ad-476e-ae90-a78e301bb791
  AGGREGATION_WINDOW_MS=10000
  LISTEN_KEY_KEEP_ALIVE_MS=1500000
  LOG_LEVEL=info
  MAX_RETRY=3
  ```

## 8. 错误处理与恢复

- **监听断开**：`streamClient` 捕获 `close`、`error` 时启动重连流程（退避 1/2/4/8/16 秒），超过 5 次仍失败则上报并退出（可拓展为报警）。
- **listenKey 过期**：捕获 `listenKeyExpired` 事件或 keep-alive 失败时立即申请新 listenKey 并重连。
- **JSON 解析失败**：记录原始消息（限 size）并忽略，避免阻塞。
- **聚合任务异常**：`aggregator` 应对 `cardBuilder` 或 `notifier` 返回错误进行捕获并写日志，同时确保上下文清理，防止内存泄漏。
- **通知失败**：`notifier` 在连续失败后将异常上抛至 `app/service`，可选实现报警或降级策略。

## 9. 日志策略

- **结构化字段**：`symbol`、`orderId`、`clientOrderId`、`scenario`、`status`、`eventTime`、`attempt` 等。
- **关键节点**：listenKey 生命周期、WebSocket 连接状态、聚合窗口操作、卡片发送结果。
- **等级控制**：
  - `info`：正常状态转变与通知。
  - `warn`：重连、重试等。
  - `error`：API 调用失败、无法恢复的异常。

## 10. 测试策略

- **单元测试**（使用 `vitest` + `ts-mockito`）：
  - `eventMapper`：针对不同 `clientOrderId`、`orderType` 判断结果。
  - `aggregator`：模拟场景（一次性成交、分批成交、取消等），验证与 `docs/场景用例.md` 输出一致。
  - `cardBuilder`：校验生成的字段与文案。
- **集成测试**：
  - 使用 `ws` mock server + 预定义 `ORDER_TRADE_UPDATE` 序列驱动全流程，断言发送出的卡片内容。
  - 飞书 webhook mock（本地 HTTP server）验证请求结构。
- **端到端演练**：在测试网下下单（市价单 / `SL` / `TP`）对照场景文档确认飞书消息。
- **回归脚本**：编写脚本对 `docs/场景用例.md` 中每个场景生成对应输入与预期输出，作为自动化断言。

## 11. 里程碑建议

1. **基础环境**：建立 TypeScript 项目架构、lint/format（ESLint + Prettier）、基础配置加载。
2. **Binance 接入**：完成 listenKey 管理 + WebSocket 客户端，打印原始订阅事件。
3. **事件过滤与追踪**：实现 `eventMapper`、`stateTracker`，确保能在日志中看到关键字段更新。
4. **聚合与通知**：完成 `aggregator`、`cardBuilder`、`notifier`，对每个场景编写测试用例。
5. **异常处理与稳定性**：补齐重连、重试、错误日志，确保长期运行稳定。
6. **验收**：根据 `docs/场景用例.md` 逐项验证，整理上线操作手册。

## 12. 后续扩展建议（非当前范围）

- 支持多 listenKey / 多子账号并行监听。
- 将通知结果写入数据库或监控系统（如 Prometheus 指标）。
- 根据 `ORDER_TRADE_UPDATE` 中的 `rp`、`b` 字段扩展盈亏提示。

## 13. 币安持仓校验设计

> **对齐要求**：实现需覆盖 `docs/场景用例.md` 中“币安持仓校验”章节的所有场景，禁止自行增删业务条件；若场景更新，应先同步该文档。

### 13.1 范围与目标

- **目标账户**：币安 U 本位合约账户（逐仓/全仓均适用）。
- **监控对象**：账户层总保证金、全部持仓的杠杆、保证金占比、下一次预估资费利率、白/黑名单配置符合度。
- **输出形式**：生成结构化 `ValidationIssue`，供后续飞书推送或其他通知渠道复用；支持告警限流与恢复提示。

### 13.2 数据源与采集频率

- `GET /fapi/v2/account`：提供 `totalMarginBalance`、`totalInitialMargin` 等全局数据。
- `GET /fapi/v2/positionRisk`：获取每个交易对的方向、杠杆、名义价值、初始保证金，兼容逐仓/全仓。
- `GET /fapi/v1/premiumIndex`：查询交易对的 `lastFundingRate`、`nextFundingTime`、`predictedFundingRate`（下一次预估）。
- **调度策略**：默认轮询间隔 30 秒（可通过环境变量 `POSITION_VALIDATION_INTERVAL_MS` 调整）；若后续对接事件驱动（如 WebSocket `ACCOUNT_UPDATE`）再行优化。
- **缓存策略**：`premiumIndex` 支持 60 秒缓存，减少频繁调用；当缓存过期或请求失败时记录数据状态。

### 13.3 数据归一与模型

- `PositionSnapshot`
  - `baseAsset`：基础币种（`BTCUSDT` → `BTC`）。
  - `direction`：`long` / `short`。
  - `symbol`：完整交易对。
  - `leverage`、`notional`、`initialMargin`、`positionAmt`、`isolatedMargin`。
  - `predictedFundingRate`：下一次预估资费利率。
  - `updatedAt`：快照生成时间。
- `AccountContext`
  - `totalMarginBalance`（账户总保证金）。
  - `totalInitialMargin`、`availableBalance`（可用于扩展校验）。
  - `snapshots`：`PositionSnapshot[]`。
- 构建时需过滤 0 仓位（`positionAmt = 0`）以降低噪音，但若白名单要求必持仍需提供“缺失”信号（详见 13.5）。

### 13.4 配置模型

- `PositionRulesConfig`
  - `defaults`
    - `whitelistLong`、`whitelistShort`、`blacklistLong`、`blacklistShort`。
    - `maxLeverage`。
    - `maxMarginShare`（数值 0-1，例如 0.05 表示 5%）。
    - `fundingThresholdLong` / `fundingThresholdShort`（例：`-0.002`）。
    - `cooldownMinutes`（默认 60，用于限流）。
  - `overrides`: 以基础币种为 key（如 `BTC`），值为与 `defaults` 相同字段的局部覆盖。
- 使用 `zod` 校验配置文件（`config/positionRules.ts`），构建时生成 `Map<baseAsset, DirectionRule>`；未命中时回退默认值。
- 对于必持仓场景，引入 `whitelistRequiredLong`/`whitelistRequiredShort` 标记，缺失时生成“缺失告警”。

**配置示例（`config/position-rules.json`）**

```json
{
  "defaults": {
    "maxLeverage": 3,
    "maxMarginShare": 0.05,
    "fundingThresholdShort": -0.002,
    "cooldownMinutes": 60,
    "requireLongAssets": ["BTC"],
    "forbidShortAssets": ["BTC"]
  },
  "overrides": {
    "BTC": {
      "maxLeverage": 10,
      "maxMarginShare": 0.5,
      "fundingThresholdShort": -0.001,
      "notifyRecovery": true
    },
    "ETH": {
      "requireLong": false,
      "requireShort": true,
      "cooldownMinutes": 15
    }
  }
}
```

### 13.5 校验器设计

- 每条规则实现 `Validator` 接口：`validate(snapshot, accountContext, ruleConfig) => ValidationIssue[]`。
- **白/黑名单**：
  - 白名单必持：无对应方向持仓（含仓位为 0）时产出 `MissingPositionIssue`。
  - 黑名单：检测到持仓（`notional != 0`）立即产出 `ForbiddenPositionIssue`。
- **杠杆限制**：比较 `snapshot.leverage` 与阈值，超过则生成 `LeverageOverflowIssue`。
- **单币种保证金占比**：计算 `snapshot.initialMargin / accountContext.totalMarginBalance`；若超过阈值输出 `MarginShareOverflowIssue`。
- **总保证金使用率**：基于 `accountContext.totalInitialMargin / totalMarginBalance`；超过 100% 触发 `TotalMarginUsageIssue`。
- **资费利率**：按方向读取相应阈值，与 `predictedFundingRate` 比较；低于阈值生成 `FundingRateIssue`。
- 校验器应在数据缺失时返回 `DataUnavailableIssue`，并附上下文（缺失字段、调用状态），便于诊断。

### 13.6 告警限流策略

- 构建 `issueKey = ${ruleType}:${baseAsset}:${direction}`（总保证金使用率无方向则使用 `global`）。
- 维护 `Map<issueKey, AlertState>`：`{status: 'alert' | 'resolved', lastSentAt, firstDetectedAt, lastValue}`。
- 流程：
  1. 新告警：若不存在 `issueKey` 或当前状态为 `resolved`，立即发送，并记录 `alert` 状态。
  2. 重复告警：若距离 `lastSentAt` 小于规则冷静期，则仅刷新 `lastValue`、`firstDetectedAt`（首次延续时）并写 debug 日志；超过冷静期再发送“持续告警”并更新 `lastSentAt`。
  3. 告警恢复：当校验不再触发时，标记为 `resolved`，可选择发送恢复通知；若配置中 `notifyRecovery = false`，则仅记录日志并清理状态。
- Funding rate 等易抖动指标，可叠加 `minDelta`（绝对值变化最小阈值）以减少频繁触发，配置默认 0，按需开启。
- 若服务支持多实例，需要将 `AlertState` 落入 Redis/数据库，或改成单实例调度。

### 13.7 执行流程

1. 调度器触发数据采集，构建 `AccountContext`。
2. 基于配置生成“缺失必持仓”检查列表，对未出现的白名单币种直接产出 `MissingPositionIssue`。
3. 遍历 `snapshots`，对每条持仓依次运行全部 `Validator` 并收集 `ValidationIssue`。
4. 汇总结果并交给 `AlertLimiter` 去重/限流，返回最终需要通知的列表。
5. 将告警/恢复事件交给通知层（可沿用现有飞书卡片结构，增加专属模板）。
6. 完成后更新 `AlertState`，并记录指标（总校验数、告警数、数据异常数）。

### 13.8 错误处理与监控

- REST 调用失败：重试（指数退避 + 最大次数），仍失败则生成全局 `DataUnavailableIssue` 并通知，同时保持旧数据缓存 1 个周期备用。
- 数据缺失或结构异常：在日志中记录原始响应（截断敏感信息），并附带 `requestId`。
- 限流状态异常（时间倒退、记录缺失）：在日志中输出告警并重置对应 `issueKey`，防止压制合法告警。
- 指标：可复用现有监控或新增 `validation_total`, `validation_issues_total`, `validation_data_errors_total` 三项。

### 13.9 测试策略补充

- 单元测试：为每个 `Validator` 构造边界样例（刚好等于阈值、超过阈值、数据缺失）。
- 集成测试：模拟 REST 响应 + 配置，跑完调度流程断言告警列表及限流行为（包含冷静期内重复触发、恢复后再次触发）。
- 性能测试：构造上百个持仓快照，确保在默认间隔内校验完成，并统计耗时。
